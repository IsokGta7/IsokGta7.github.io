---
layout: default
title: Numbers
permalink: /numbers/
---

<div class="login-container">
    <h2>Numbers</h2>
</div>

<div class="canvas-container">
    <h1>Dibuja un número para que el modelo diga que número es más probable que sea</h1>
    <canvas id="drawingCanvas" width="280" height="280" style="border:1px solid black;"></canvas>
    <br>
    <button id="predictButton" disabled>Predecir</button>
    <button id="clearButton">Limpiar Canvas</button>
    <h2>Resultado: <span id="result"></span></h2>
    <p id="status">Cargando el modelo...</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script>
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const predictButton = document.getElementById('predictButton');
    const clearButton = document.getElementById('clearButton');
    const statusText = document.getElementById('status');
    let isDrawing = false;
    let model;

    async function loadModel() {
        try {
            model = await tf.loadLayersModel('model_numbers.json');
            console.log("Modelo cargado correctamente:", model.summary());
            statusText.innerText = "Modelo cargado.";
            predictButton.disabled = false;
        } catch (error) {
            console.error("Error al cargar el modelo:", error);
            statusText.innerText = "Error cargando el modelo.";
        }
    }

    // Preprocesar el lienzo
    async function preprocessCanvas() {
        let image = tf.browser.fromPixels(canvas, 1); // 1 canal para escala de grises
        image = tf.image.resizeBilinear(image, [28, 28]);
        image = image.div(255.0); // Normalización
        const reshaped = image.expandDims(0); // Añadir dimensión para batch
        return reshaped;
    }

    // Obtener la posición del mouse o del dedo en el canvas
    function getPosition(event) {
        const rect = canvas.getBoundingClientRect();
        if (event.touches) {
            return {
                x: event.touches[0].clientX - rect.left,
                y: event.touches[0].clientY - rect.top
            };
        } else {
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }
    }

    // Comenzar a dibujar
    function startDrawing(event) {
        isDrawing = true;
        const pos = getPosition(event);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        event.preventDefault(); // Evitar el scroll en dispositivos táctiles
    }

    // Dejar de dibujar
    function stopDrawing() {
        isDrawing = false;
    }

    // Dibujar en el canvas
    function draw(event) {
        if (!isDrawing) return;
        const pos = getPosition(event);
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        event.preventDefault(); // Evitar el scroll en dispositivos táctiles
    }

    // Eventos para mouse
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mousemove', draw);

    // Eventos para touch (dispositivos móviles)
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchend', stopDrawing);
    canvas.addEventListener('touchmove', draw);

    // Limpiar el lienzo
    clearButton.addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        document.getElementById('result').innerText = "";
    });

    async function predictDigit() {
        if (!model) {
            alert("El modelo no se ha cargado todavía.");
            return;
        }
        try {
            const inputTensor = await preprocessCanvas();
            const predictions = model.predict(inputTensor);
            const predictedClass = predictions.argMax(-1).dataSync()[0];

            document.getElementById('result').innerText = predictedClass;
        } catch (error) {
            console.error("Error durante la predicción:", error);
        }
    }

    // Escuchar clic del botón de predicción
    predictButton.addEventListener('click', predictDigit);

    // Cargar el modelo al cargar la página
    window.onload = loadModel;
</script>

<style>
    .canvas-container {
        margin-top: 20px;
        text-align: center;
    }

    #drawingCanvas {
        cursor: crosshair;
        width: 280px;
        height: 280px;
    }

    #status {
        font-style: italic;
        color: gray;
    }
</style>
