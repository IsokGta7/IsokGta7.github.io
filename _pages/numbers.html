---
layout: default
title: Numbers
permalink: /numbers/
---

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reconocimiento de Números</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }

        canvas {
            border: 1px solid black;
            background-color: white;
        }
    </style>
</head>

<body>
    <h1>Dibuja un número para que el modelo diga qué número es más probable que sea</h1>
    <canvas id="drawingCanvas" width="280" height="280"></canvas>
    <br>
    <button id="predictButton" disabled>Predecir</button>
    <button id="clearButton">Limpiar Canvas</button>
    <h2>Resultado: <span id="result"></span></h2>
    <p id="status">Cargando el modelo...</p>
    <h2>Imagen procesada (28x28)</h2>
    <canvas id="processedCanvas" width="28" height="28"></canvas>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const processedCanvas = document.getElementById('processedCanvas');
        const processedCtx = processedCanvas.getContext('2d');
        const predictButton = document.getElementById('predictButton');
        const clearButton = document.getElementById('clearButton');
        const statusText = document.getElementById('status');
        let isDrawing = false;
        let model;

        async function loadModel() {
            try {
                model = await tf.loadLayersModel('model_numbers.json');
                statusText.innerText = "Modelo cargado.";
                predictButton.disabled = false;
            } catch (error) {
                console.error("Error al cargar el modelo:", error);
                statusText.innerText = "Error cargando el modelo.";
            }
        }

        function getMousePosition(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (event) => {
            isDrawing = true;
            const mousePos = getMousePosition(canvas, event);
            ctx.beginPath();
            ctx.moveTo(mousePos.x, mousePos.y);
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mousemove', (event) => {
            if (!isDrawing) return;
            const mousePos = getMousePosition(canvas, event);
            ctx.lineWidth = 15;
            ctx.lineCap = 'round';
            ctx.strokeStyle = 'black';
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mousePos.x, mousePos.y);
        });

        clearButton.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            document.getElementById('result').innerText = "";
        });

        async function preprocessCanvas() {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = 28;
            tempCanvas.height = 28;
            tempCtx.drawImage(canvas, 0, 0, 28, 28);

            // Mostrar en el canvas procesado
            processedCtx.drawImage(tempCanvas, 0, 0, 28, 28);

            // Obtener los datos de imagen directamente sin preprocesado
            const imageData = tempCtx.getImageData(0, 0, 28, 28).data;

            // Normalizar los datos de la imagen a escala de 0 a 1
            const normalizedData = [];
            for (let i = 0; i < imageData.length; i += 4) {
                normalizedData.push(imageData[i] / 255); // Normaliza el valor
            }

            // Crear el tensor sin procesamiento adicional
            const inputTensor = tf.tensor4d(normalizedData, [1, 28, 28, 1]);
            return inputTensor;
        }



        async function predictDigit() {
            if (!model) {
                alert("El modelo no se ha cargado todavía.");
                return;
            }
            try {
                const inputTensor = await preprocessCanvas();
                const predictions = model.predict(inputTensor);
                const predictionArray = predictions.dataSync();
                const probabilities = Array.from(predictionArray);
                const predictedClass = probabilities.indexOf(Math.max(...probabilities));

                document.getElementById('result').innerText = predictedClass;
            } catch (error) {
                console.error("Error durante la predicción:", error);
            }
        }

        predictButton.addEventListener('click', predictDigit);
        window.onload = loadModel;
    </script>
</body>