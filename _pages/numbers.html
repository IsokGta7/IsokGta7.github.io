---
layout: default
title: Reconocimiento de números
description: Demo ligera de MNIST en TensorFlow.js con canvas optimizado para escritura a mano.
permalink: /numbers/
---

<section class="demo-card">
  <div class="section-title">
    <div>
      <p class="eyebrow" data-i18n-en="CNN · MNIST">CNN · MNIST</p>
      <h2 data-i18n-en="Handwritten number recognition">Reconocimiento de números escritos a mano</h2>
      <p class="subtle-text" data-i18n-en="Draw on the canvas; client-side normalization enables instant predictions.">Dibuja en el lienzo, optimizado con normalización en cliente para predicciones inmediatas.</p>
    </div>
    <span id="numbers-status" class="status-pill" data-i18n-en="Loading model...">Cargando modelo...</span>
  </div>

  <div class="summary-grid">
    <div class="summary-card">
      <h3 data-i18n-en="How it works">Cómo funciona</h3>
      <ul>
        <li data-i18n-en="Canvas 224x224 is reduced to 28x28 grayscale.">El lienzo 224x224 se reduce a 28x28 en escala de grises.</li>
        <li data-i18n-en="Normalized to 0-1 and adds batch dimension (1, 28, 28, 1).">Se normaliza a 0-1 y se agrega dimensión batch (1, 28, 28, 1).</li>
        <li data-i18n-en="MNIST model returns probabilities and shows the top-1 class.">El modelo MNIST devuelve probabilidades y se muestra la clase top-1.</li>
      </ul>
    </div>
    <div class="summary-card">
      <h3 data-i18n-en="Tips">Tips</h3>
      <ul>
        <li data-i18n-en="Draw large numbers with continuous strokes.">Dibuja números grandes y con trazos continuos.</li>
        <li data-i18n-en="Use “Clear” to reset the canvas and avoid artifacts.">Usa “Limpiar” para reiniciar el canvas y evitar residuos.</li>
        <li data-i18n-en="If switching from touch to mouse, click inside the canvas before drawing.">Si cambias de dispositivo táctil a mouse, vuelve a pulsar dentro del lienzo antes de dibujar.</li>
      </ul>
    </div>
  </div>

  <div class="canvas-panel">
    <div class="canvas-wrapper">
      <canvas id="numbers-canvas" width="224" height="224"></canvas>
    </div>
    <div class="controls">
      <button id="predict-btn" class="button" disabled data-i18n-en="Predict">Predecir</button>
      <button id="clear-btn" class="button secondary" data-i18n-en="Clear">Limpiar</button>
    </div>
    <p id="numbers-output" class="prediction-output">Dibuja y presiona predecir.</p>
  </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('numbers-canvas');
    const ctx = canvas.getContext('2d');
    const predictBtn = document.getElementById('predict-btn');
    const clearBtn = document.getElementById('clear-btn');
    const statusPill = document.getElementById('numbers-status');
    const output = document.getElementById('numbers-output');
    let model;
    let isDrawing = false;

    const copy = {
      status: {
        loading: { es: 'Cargando modelo...', en: 'Loading model...' },
        ready: { es: 'Modelo listo', en: 'Model ready' },
        error: { es: 'Error cargando modelo', en: 'Error loading model' }
      },
      output: {
        prompt: { es: 'Dibuja y presiona predecir.', en: 'Draw and press predict.' },
        result: { es: 'Predicción', en: 'Prediction' }
      }
    };

    function translate(map) {
      return (window.SiteI18n && window.SiteI18n.translate) ? window.SiteI18n.translate(map) : (map?.es || '');
    }

    function setStatus(key, state = '') {
      const text = translate(copy.status[key] || { es: key, en: key });
      statusPill.textContent = text;
      statusPill.className = `status-pill ${state}`.trim();
    }

    function resetCanvas() {
      ctx.fillStyle = '#0b1222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      output.textContent = translate(copy.output.prompt);
    }

    function pointerPosition(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
      return { x, y };
    }

    function startDrawing(e) {
      isDrawing = true;
      const { x, y } = pointerPosition(e);
      ctx.beginPath();
      ctx.moveTo(x, y);
    }

    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const { x, y } = pointerPosition(e);
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 12;
      ctx.lineCap = 'round';
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y);
    }

    function stopDrawing() {
      isDrawing = false;
      ctx.beginPath();
    }

    async function loadModel() {
      try {
        await tf.ready();
        model = await tf.loadLayersModel('{{ '/assets/numbers/model_numbers.json' | relative_url }}');
        setStatus('ready', 'ready');
        predictBtn.disabled = false;
      } catch (error) {
        console.error('Error loading model', error);
        setStatus('error', 'error');
      }
    }

    function preprocess() {
      return tf.tidy(() => {
        const temp = document.createElement('canvas');
        temp.width = 28;
        temp.height = 28;
        const tctx = temp.getContext('2d');
        tctx.drawImage(canvas, 0, 0, 28, 28);
        const imgData = tctx.getImageData(0, 0, 28, 28);
        const img = tf.browser.fromPixels(imgData, 1).toFloat().div(255);
        return img.expandDims(0);
      });
    }

    async function predict() {
      if (!model) return;
      const input = preprocess();
      const prediction = model.predict(input);
      const data = await prediction.data();
      const idx = data.indexOf(Math.max(...data));
      const label = translate(copy.output.result);
      output.textContent = `${label}: ${idx}`;
      tf.dispose([input, prediction]);
    }

    function attachDrawingEvents() {
      ['mousedown', 'touchstart'].forEach(evt => canvas.addEventListener(evt, startDrawing));
      ['mousemove', 'touchmove'].forEach(evt => canvas.addEventListener(evt, draw));
      ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(evt => canvas.addEventListener(evt, stopDrawing));
    }

    predictBtn.addEventListener('click', predict);
    clearBtn.addEventListener('click', resetCanvas);

    attachDrawingEvents();
    resetCanvas();
    loadModel();

    document.addEventListener('language:change', () => {
      resetCanvas();
      setStatus(model ? 'ready' : 'loading', model ? 'ready' : '');
    });
  });
</script>
