<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Predictions</title>
    <link rel="stylesheet" href="/eirodriguezt/styles/style.css"> <!-- Link to external stylesheet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>

<body>
    <header>
        <nav>
            <ul>
                <li><a href="/eirodriguezt/index.html">Inicio</a></li>
            </ul>
        </nav>
        <h1>BTC/USDT Predictions</h1>
    </header>

    <main>
        <!-- First Chart: Prediction -->
        <div class="chart-container">
            <h2>Prediction Chart</h2>
            <canvas id="predictionChart" width="400" height="200"></canvas>
        </div>

        <!-- Second Chart: Real vs Predicted Comparison -->
        <div class="chart-container">
            <h2>Real vs Predicted Comparison</h2>
            <canvas id="comparisonChart" width="400" height="200"></canvas>
        </div>
    </main>

    <footer>
        <p>&copy; Predicci√≥n de BTC. Ezequiel Isaac Rodriguez Tenorio.</p>
    </footer>

    <script>
        // Load the TensorFlow.js model
        let model;

        tf.loadLayersModel('/eirodriguezt/assets/bitcoin/model_btc.json').then(loadedModel => {
            model = loadedModel;
            console.log('Model loaded successfully!');

            // Compile the model after loading it
            model.compile({
                optimizer: 'adam',  // Or use a different optimizer if needed
                loss: 'meanSquaredError',  // This is commonly used for regression tasks
                metrics: ['mae']  // Optionally, you can add metrics like Mean Absolute Error
            });
        });

        // Set up Chart.js for Prediction
        const predictionCtx = document.getElementById('predictionChart').getContext('2d');
        const predictionChart = new Chart(predictionCtx, {
            type: 'line',
            data: {
                labels: [], // Timestamps
                datasets: [
                    {
                        label: 'Prediction',
                        data: [],
                        borderColor: 'red',
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        }
                    }
                }
            }
        });

        // Set up Chart.js for Comparison
        const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
        const comparisonChart = new Chart(comparisonCtx, {
            type: 'line',
            data: {
                labels: [], // Timestamps
                datasets: [
                    {
                        label: 'Real Value',
                        data: [],
                        borderColor: 'blue',
                        fill: false
                    },
                    {
                        label: 'Prediction',
                        data: [],
                        borderColor: 'red',
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        }
                    }
                }
            }
        });

        // Store historical data for training
        let historicalData = [];

        // Fetch data from Binance API (Last 240 data points)
        async function fetchBinanceData() {
            const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=240'; // Fetch the last 240 data points (4 hours)
            const response = await fetch(url);
            const data = await response.json();

            // Extract relevant fields for prediction
            const timestamps = data.map(candle => new Date(candle[0]).toISOString()); // Timestamps
            const closingPrices = data.map(candle => parseFloat(candle[4])); // Closing prices
            return { timestamps, closingPrices };
        }

        // Train the model on batches and then make predictions
        async function updateCharts() {
            const { timestamps, closingPrices } = await fetchBinanceData();

            // Accumulate the historical data over time
            historicalData = historicalData.concat(closingPrices);

            // Process the data in batches of 60
            const batchSize = 60;
            const batches = [];
            for (let i = 0; i <= historicalData.length - batchSize; i++) {
                batches.push(historicalData.slice(i, i + batchSize)); // Create batches of 60
            }

            // Train the model with new data
            await trainModel(batches);

            // Make predictions for each batch
            const predictions = [];
            batches.forEach(batch => {
                const inputTensor = tf.tensor(batch).reshape([1, batchSize, 1]);
                const predictionTensor = model.predict(inputTensor);
                const prediction = predictionTensor.dataSync()[0];
                predictions.push(prediction);
            });

            // Update the prediction chart with the predictions from all batches
            predictionChart.data.labels = timestamps.slice(0, predictions.length); // Update labels with the time range of predictions
            predictionChart.data.datasets[0].data = predictions;
            predictionChart.update();

            // For the comparison chart, just take the most recent 60 data points for comparison
            const latestRealValue = closingPrices[closingPrices.length - 1];

            comparisonChart.data.labels.push(timestamps[timestamps.length - 1]);
            comparisonChart.data.datasets[0].data.push(latestRealValue); // Real value (blue)
            comparisonChart.data.datasets[1].data.push(predictions[predictions.length - 1]); // Prediction (red)
            comparisonChart.update();

            // Limit the charts to the last 100 data points
            if (predictionChart.data.labels.length > 100) {
                predictionChart.data.labels.shift();
                predictionChart.data.datasets[0].data.shift();
            }

            if (comparisonChart.data.labels.length > 100) {
                comparisonChart.data.labels.shift();
                comparisonChart.data.datasets[0].data.shift();
                comparisonChart.data.datasets[1].data.shift();
            }
        }

        // Function to train the model on new batches
        async function trainModel(batches) {
            const batchSize = 60;
            const trainingData = [];
            const labels = [];

            batches.forEach(batch => {
                const inputTensor = tf.tensor(batch).reshape([1, batchSize, 1]);
                const label = batch[batch.length - 1]; // Use the last value as the label for prediction
                trainingData.push(inputTensor);
                labels.push(label);
            });

            // Train the model with the new batches
            const xs = tf.concat(trainingData);
            const ys = tf.tensor(labels).reshape([labels.length, 1]);

            await model.fit(xs, ys, {
                epochs: 1,
                batchSize: 32
            });

            console.log('Model trained on new data!');
        }

        // Fetch the data immediately on page load, and then every minute
        updateCharts(); // Initial data fetch
        setInterval(updateCharts, 60000); // Fetch new data every minute
    </script>

</body>

</html>