<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC/USDT Predictions</title>
    <link rel="stylesheet" href="/eirodriguezt/styles/style.css"> <!-- Link to external stylesheet -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
</head>

<body>
    <header>
        <nav>
            <ul>
                <li><a href="/eirodriguezt/index.html">Inicio</a></li>
            </ul>
        </nav>
        <h1>BTC/USDT Predictions</h1>
    </header>

    <main>
        <!-- First Chart: Prediction -->
        <div class="chart-container">
            <h2>Prediction Chart</h2>
            <canvas id="predictionChart" width="400" height="200"></canvas>
        </div>

        <!-- Second Chart: Real vs Predicted Comparison -->
        <div class="chart-container">
            <h2>Real vs. Predicted Comparison</h2>
            <canvas id="comparisonChart" width="400" height="200"></canvas>
        </div>
    </main>

    <footer>
        <p>&copy; Predicci√≥n de BTC. Ezequiel Isaac Rodriguez Tenorio.</p>
    </footer>

    <script>
        // Load the TensorFlow.js model
        let model;

        tf.loadLayersModel('/eirodriguezt/assets/bitcoin/model_btc.json').then(loadedModel => {
            model = loadedModel;
            console.log('Model loaded successfully!');
        }).catch(error => {
            console.error('Error loading the model:', error);
        });

        // Variables para normalizar/desnormalizar
        let dataMean = null;
        let dataStd = null;

        // Initialize Prediction Chart
        const predictionCtx = document.getElementById('predictionChart').getContext('2d');
        const predictionChart = new Chart(predictionCtx, {
            type: 'line',
            data: {
                labels: [], // Timestamps
                datasets: [
                    {
                        label: 'Prediction',
                        data: [],
                        borderColor: 'red',
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        }
                    }
                }
            }
        });

        // Initialize Real vs Predicted Comparison Chart
        const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
        const comparisonChart = new Chart(comparisonCtx, {
            type: 'line',
            data: {
                labels: [], // Timestamps
                datasets: [
                    {
                        label: 'Real Value',
                        data: [],
                        borderColor: 'blue',
                        fill: false
                    },
                    {
                        label: 'Prediction',
                        data: [],
                        borderColor: 'red',
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute'
                        }
                    }
                }
            }
        });

        // Buffer to hold the last 60 closing prices
        let recentData = [];

        // Fetch data from Binance
        async function fetchBinanceData() {
            try {
                const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=100';
                const response = await fetch(url);
                const data = await response.json();

                // Extract relevant fields for prediction
                const timestamps = data.map(candle => new Date(candle[0]).toISOString());
                const closingPrices = data.map(candle => parseFloat(candle[4]));

                // Ensure valid data
                if (!closingPrices.every(price => isFinite(price))) {
                    console.error('Invalid price data detected');
                    return { timestamps: [], closingPrices: [] };
                }

                // Calculate mean and std for normalization
                if (dataMean === null || dataStd === null) {
                    const tensorPrices = tf.tensor(closingPrices);
                    dataMean = tensorPrices.mean().arraySync();
                    dataStd = tensorPrices.sub(dataMean).square().mean().sqrt().arraySync();
                }

                return { timestamps, closingPrices };
            } catch (error) {
                console.error('Error fetching Binance data:', error);
                return { timestamps: [], closingPrices: [] };
            }
        }

        // Preprocess data and make predictions
        async function updateCharts() {
            const { timestamps, closingPrices } = await fetchBinanceData();

            if (closingPrices.length === 0 || timestamps.length === 0) {
                return; // Stop if there's an error or no valid data
            }

            // Update the recent data buffer
            recentData = recentData.concat(closingPrices);

            // Process in batches of 60 data points
            while (recentData.length >= 60) {
                const batch = recentData.slice(0, 60);
                recentData = recentData.slice(1); // Slide the buffer (remove oldest value)

                // Normalize the input data
                const inputTensor = tf.tensor(batch).sub(dataMean).div(dataStd).reshape([1, 60, 1]);

                // Predict using the model
                try {
                    const predictionTensor = model.predict(inputTensor);
                    const normalizedPrediction = predictionTensor.dataSync()[0]; // Single prediction value

                    // Desnormalize the prediction back to the original scale
                    const prediction = normalizedPrediction * dataStd + dataMean;

                    // Update charts
                    predictionChart.data.labels.push(timestamps[0]);
                    predictionChart.data.datasets[0].data.push(prediction);
                    predictionChart.update();

                    // Add to comparison chart
                    comparisonChart.data.labels.push(timestamps[0]);
                    comparisonChart.data.datasets[0].data.push(batch[batch.length - 1]); // Real value
                    comparisonChart.data.datasets[1].data.push(prediction); // Predicted value
                    comparisonChart.update();

                    // Limit the number of data points in the chart
                    if (predictionChart.data.labels.length > 100) {
                        predictionChart.data.labels.shift();
                        predictionChart.data.datasets[0].data.shift();
                    }
                    if (comparisonChart.data.labels.length > 100) {
                        comparisonChart.data.labels.shift();
                        comparisonChart.data.datasets[0].data.shift();
                        comparisonChart.data.datasets[1].data.shift();
                    }
                } catch (error) {
                    console.error('Error in prediction:', error);
                }
            }
        }

        // Fetch the data immediately on page load, and then every minute
        updateCharts();
        setInterval(updateCharts, 60000);

    </script>

</body>

</html>