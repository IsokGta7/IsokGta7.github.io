---
layout: default
title: Predicción BTC/USDT
description: Serie temporal con LSTM en TensorFlow.js y visualización en Chart.js.
permalink: /bitcoin/
---

<section class="demo-card">
  <div class="section-title">
    <div>
      <p class="eyebrow" data-i18n-en="Time series">Series de tiempo</p>
      <h2 data-i18n-en="BTC/USDT price prediction">Predicción de precios BTC/USDT</h2>
      <p class="subtle-text" data-i18n-en="Client-side normalization and controlled updates with Binance data.">Normalización en cliente y actualización controlada con datos de Binance.</p>
    </div>
    <span id="btc-status" class="status-pill" data-i18n-en="Loading model...">Cargando modelo...</span>
  </div>

  <div class="summary-grid">
    <div class="summary-card">
      <h3 data-i18n-en="How it works">Cómo funciona</h3>
      <ul>
        <li data-i18n-en="Downloads 1m candles from Binance and normalizes close price.">Descarga velas 1m desde Binance y normaliza precio de cierre.</li>
        <li data-i18n-en="Generates 60-step windows and sends them to a lightweight TF.js LSTM.">Genera ventanas de 60 pasos y las envía al LSTM ligero en TF.js.</li>
        <li data-i18n-en="Denormalizes the prediction and compares against the latest real value.">Desnormaliza la predicción y la compara contra el último valor real.</li>
      </ul>
    </div>
    <div class="summary-card">
      <h3 data-i18n-en="Quick test">Para probar rápido</h3>
      <ul>
        <li data-i18n-en="Click “Start updates” to trigger inferences each cycle.">Haz clic en “Iniciar actualizaciones” para disparar inferencias cada ciclo.</li>
        <li data-i18n-en="Use “Stop” to clear intervals and free tensors.">Usa “Detener” para limpiar intervalos y liberar tensores.</li>
        <li data-i18n-en="Watch both charts to validate deviations in real time.">Observa las dos gráficas para validar desviaciones en tiempo real.</li>
      </ul>
    </div>
  </div>

  <div class="controls">
    <button id="btc-start" class="button" data-i18n-en="Start updates">Iniciar actualizaciones</button>
    <button id="btc-stop" class="button secondary" disabled data-i18n-en="Stop">Detener</button>
  </div>

  <div class="chart-grid">
    <div class="chart-wrapper">
      <h3 data-i18n-en="Prediction">Predicción</h3>
      <canvas id="predictionChart" height="200"></canvas>
    </div>
    <div class="chart-wrapper">
      <h3 data-i18n-en="Real vs Predicted">Real vs Predicho</h3>
      <canvas id="comparisonChart" height="200"></canvas>
    </div>
  </div>
</section>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    let model;
    let dataMean = null;
    let dataStd = null;
    let recentData = [];
    let intervalId;

    const statusPill = document.getElementById('btc-status');
    const startBtn = document.getElementById('btc-start');
    const stopBtn = document.getElementById('btc-stop');

    const copy = {
      status: {
        loading: { es: 'Cargando modelo...', en: 'Loading model...' },
        ready: { es: 'Modelo listo', en: 'Model ready' },
        error: { es: 'Error al cargar modelo', en: 'Error loading model' },
        running: { es: 'Actualizando datos...', en: 'Updating data...' },
        stopped: { es: 'Detenido', en: 'Stopped' }
      },
      chart: {
        prediction: { es: 'Predicción', en: 'Prediction' },
        real: { es: 'Valor real', en: 'Real value' },
        predicted: { es: 'Predicción', en: 'Prediction' }
      }
    };

    let statusKey = 'loading';
    let statusState = '';

    function translate(map) {
      return (window.SiteI18n && window.SiteI18n.translate) ? window.SiteI18n.translate(map) : (map?.es || '');
    }

    function setStatus(key, state = '') {
      statusKey = key;
      statusState = state;
      const text = translate(copy.status[key] || { es: key, en: key });
      statusPill.textContent = text;
      statusPill.className = `status-pill ${state}`.trim();
    }

    function chartLabels() {
      return {
        prediction: translate(copy.chart.prediction),
        real: translate(copy.chart.real),
        predicted: translate(copy.chart.predicted)
      };
    }

    const labels = chartLabels();

    const predictionChart = new Chart(document.getElementById('predictionChart').getContext('2d'), {
      type: 'line',
      data: { labels: [], datasets: [{ label: labels.prediction, data: [], borderColor: '#f97316', tension: 0.25 }] },
      options: { responsive: true, scales: { x: { type: 'time', time: { unit: 'minute' } } } }
    });

    const comparisonChart = new Chart(document.getElementById('comparisonChart').getContext('2d'), {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          { label: labels.real, data: [], borderColor: '#22d3ee', tension: 0.25 },
          { label: labels.predicted, data: [], borderColor: '#f97316', tension: 0.25 }
        ]
      },
      options: { responsive: true, scales: { x: { type: 'time', time: { unit: 'minute' } } } }
    });

    function refreshChartLabels() {
      const next = chartLabels();
      predictionChart.data.datasets[0].label = next.prediction;
      comparisonChart.data.datasets[0].label = next.real;
      comparisonChart.data.datasets[1].label = next.predicted;
      predictionChart.update('none');
      comparisonChart.update('none');
    }

    async function loadModel() {
      try {
        await tf.ready();
        model = await tf.loadLayersModel('{{ '/assets/bitcoin/model_btc.json' | relative_url }}');
        setStatus('ready', 'ready');
        startBtn.disabled = false;
      } catch (error) {
        console.error('Error loading model', error);
        setStatus('error', 'error');
      }
    }

    async function fetchBinanceData() {
      try {
        const url = 'https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=10';
        const response = await fetch(url);
        const data = await response.json();
        const closing = data.map(candle => parseFloat(candle[4])).filter(Number.isFinite);
        if (closing.length === 0) return [];
        if (dataMean === null || dataStd === null) {
          const t = tf.tensor(closing);
          dataMean = t.mean().arraySync();
          dataStd = t.sub(dataMean).square().mean().sqrt().arraySync();
          t.dispose();
        }
        return closing;
      } catch (error) {
        console.error('Error fetching Binance data:', error);
        return [];
      }
    }

    function normalize(sequence) {
      const t = tf.tensor(sequence);
      const normalized = t.sub(dataMean).div(dataStd);
      t.dispose();
      return normalized;
    }

    async function predict() {
      if (!model || recentData.length < 60) return;
      const windowed = recentData.slice(-60);
      const normalized = normalize(windowed);
      const input = normalized.reshape([1, 60, 1]);
      const prediction = model.predict(input);
      const predValue = prediction.dataSync()[0];
      const denormalized = predValue * dataStd + dataMean;
      const now = new Date();

      predictionChart.data.labels.push(now);
      predictionChart.data.datasets[0].data.push(denormalized);
      predictionChart.update('none');

      comparisonChart.data.labels.push(now);
      comparisonChart.data.datasets[0].data.push(windowed[windowed.length - 1]);
      comparisonChart.data.datasets[1].data.push(denormalized);
      comparisonChart.update('none');

      normalized.dispose();
      input.dispose();
      prediction.dispose();
    }

    async function loopFetchAndPredict() {
      try {
        setStatus('running', 'ready');
        const newData = await fetchBinanceData();
        if (newData.length > 0) {
          recentData = recentData.concat(newData).slice(-300);
          await predict();
        }
      } catch (error) {
        console.error('Error during loop', error);
        setStatus('error', 'error');
        stop();
      }
    }

    function start() {
      if (intervalId) return;
      intervalId = setInterval(loopFetchAndPredict, 4000);
      startBtn.disabled = true;
      stopBtn.disabled = false;
      setStatus('running', 'ready');
    }

    function stop() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      stopBtn.disabled = true;
      startBtn.disabled = false;
      setStatus('stopped');
    }

    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);

    loadModel();
    refreshChartLabels();

    document.addEventListener('language:change', () => {
      setStatus(statusKey, statusState);
      refreshChartLabels();
    });
  });
</script>
